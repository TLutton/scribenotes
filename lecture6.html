<HTML>
<HEAD>
<TITLE>CS111: Lecture 6 Scribe Notes (10/22/14)</TITLE>
<style>
    td {
        font-family: Verdana, Helvetica, Arial, sans-serif;
        font-size: 10pt;
    }
    pre{
        color: $0033CC;
    }

    h2 {
        line-height: 40pt;
    }
    .new {
        color:#CC3300;
    }
    .new2{
        color:#CC0066;
    }
</style>
</HEAD>
<BODY>
<div align=center>
    <table border=0 width=500>
        <tr><td>

            <h1>CS 111</h1>
            <h2>Lecture 6 Scribe Notes</h2>
            <i>by Thomas Lutton & Nicholas Yee</i>

            <h3>What can go wrong?</h3>
            <p>
                (cont'd discussion of the hazards of file descriptors and opening/closing pipe from the end of lecture 5)
                <h4>File descriptors:</h4>
                <ul>
                    <li>close(-1) close(39) == 1 errno == EBADF</li>
                    <li>fd = open(...) read(fd)... fd leak</li>
                    <li>fd = open("/dev/usb/dr1"...) read(fd, ...) *unplug* read(fd, ...) // return -1</li>
                </ul>
                <h4>Race Conditons:</h4>
                <ul>
                    <li>(cat a & cabt b) > outfile // DIAGRAM</li>
                    This gives us many possible outputs: <br>
                    <pre>
    a\n    (bad: output discarded)
    b\n    (bad: output discarded)
    a\nb\n (ok)
    b\na\n (ok)
    ab\n\n (bad: interleaved)
                    </pre>
                    It should be noted that "small writes" (i.e. <= 2048 bytes) are done atomically while calls to the write system call with a large output have the potential to be interleaved. <br><br>
                    <li>(cat > a & cat > b) < infile // DIAGRAM </li>
                    <pre>
    |a| + |b| = |infile|
                    </pre>
                    <li>(cat a & cat b) | (cat > c & cat > d) </li> <br>
                    This would create a lot of race conditions since the behavior largely depends on timing which means that it is variable and therefore very difficult to debug.  The best way to debug a race condition is to not create one.  In this lecture we will be examining ways of writing code in order to avoid race conditions and write safe code. 
                </ul>


                <h4> Task: rotate a log file </h4>
                    Our goal is to keep a log of all of Apache's activity.  In order to do this, we must keep two files, log and oldlog.  log contains all of the information for the current day while oldlog contains a copy of the log file from the previous day.  <br>
                    <br>
                    log       <= apache writes to this endlessly<br>
                    oldlog    <= yesterday's log<br>
                    <br>
                    The tricky part (most prone to error) occurs when log must be transitioned to oldlog at midnight. <br>
                    <pre>
    $ mv log old log
    $ >log
                    </pre>
                    However, we need some way of telling Apache to close/reopen its log file.
                    <pre>
i.e.
    close(fd);
    fd = open("log", O_WRONLY ...);
                    </pre>
                    Right now, our writes to the log look like this:
                    <pre>
    write(fd, "good stuff\n", 11);
    write(fd, "more good stuff\n", 16);
                    </pre>
                    Can you see the problem with this attempt? Hint: Race condition<br>
                    <br>
                    With this naive writing to the log file, it is possible that the current time is midnight and the log file's location is being changed.  We need to add some sort of check to make sure that the log is being written to the correct place. Here's the change:
                    <pre>
    checklog();
    write(fd, "good stuff\n", 11);
    checklog();
    write(fd, "more good stuff\n", 16);
                    </pre>
                    with checklog() defined as follows:
                    <pre>
                        <code>
    int checklog(void) {
        if(stat("log", &st) < 0 || st.st_size == 0) {
            close(fd);
            fd = open("log",...);
        }
    }
                        </code>
                    </pre>
                    Right now Apache has to execute two system calls every time it wants to write to the log.  This is a very inelegant way to solve the problem.  This <a href="http://en.wikipedia.org/wiki/Polling_(computer_science)"><i>polling</i></a> approach is also very slow.<br>
                    <br>
                    More trouble: What would happen if the power failed? We would have the same issue. <br>
                    <br>

                <h4>Signals</h4>

                Let's start this section with an analogy.<br>
                <br>
                signals : processes :: traps : hardware.<br>
                <br>
                That's right, signals work for processes in the same way that traps work for hardware.<br>
                <br>
                <a href="http://en.wikipedia.org/wiki/Trap_(computing)">traps</a> - after any machine instruction, the equivalent of INT 0x80 can occur.<br>
                <br>
                <a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?signal+7">signals</a> - the kernel can take control and:<br>
                <ul>
                    <li>terminate processes</li>
                    <li>continue as before</li>
                    <li>cause program to call one of your functions with an asynchronous function call</li>
                </ul>
                Using signals is a good way to avoid wasting CPU resources by polling.<br>
                <br>
                <table>
                    <body>
                        <tr>
                            <td><b>Signal</b></td><td><b>Meaning</b></td><td><b>Additional Info</b></td>
                        </tr>
                        <tr>
                            <td>SIGINT</td><td>interrupt ^C</td><td> <= uncooperative process</td>
                        </tr>
                        <tr>
                            <td>SIGHUP</td><td>hang up</td><td><= unexpected loss of resources</td>
                        </tr>
                        <tr>
                            <td>SIGSEGV</td><td>segmentation violations</td>
                        </tr>
                        <tr>
                            <td>SIGBUS</td><td>bus error</td>
                        </tr>
                        <tr>
                            <td>SIGFPE</td><td>floating point exception</td><td> almost impossible to see nowadays</td>
                        </tr>
                        <tr>
                            <td>SIGPIPE</td><td>writing to pipe with no readers</td>
                        </tr>
                        <tr>
                            <td>SIGKILL</td><td>immediately makes process die</td>
                        </tr>
                        <tr>
                            <td>SIGALRM</td><td>alarm clock</td>
                        </tr>
                        <tr>
                            <td>SIGXCPU</td><td>CPU quota exceeded limit</td>
                        </tr>
                        <tr>
                            <td>SIGXFS2</td><td>file size</td>
                        </tr>
                    </body>
                </table>
                <pre>
                    <code>
int kill(pid_t pid, int sig); // send signal to process
    // can send only to own processes on lnxsrv

pid_t p = fork();
if(p > 0) {
    sleep(30);
    kill(p, SIGINT);
}
wait_pid(p, ...); // weird exit status > 127
                    </code>
                </pre>
                <pre>
                    <code>
typedef void (*sighandler_t)(int);
sighandler_t signal(int, sighandler_t); // int is sig num, returns old handler
                    </code>
                    <br>
example:
                    <code>
int main(void) {
    signal(SIGALRM, bing); // set up handler before action that provokes signal
    alarm(30);
    // really complicated main code
    return 0;
}
void bing(int sig) {
    printf("BING! %d\n", sig);
    exit(27);
}
                    </code>
                </pre>
                But there's a problem! What if the signal arrives when printf is active? This will result in undefined behavior.<br>
                <pre>
    stack:
        printf
        bing
        delicate stuff
        printf
        main
                </pre>
                Solution? Don't call printf or exit! Stick to safe function calls in the handler.<br>
                <br>
                asynchronus_safe functions:
                <ul>
                    <li>write</li>
                    <li>read</li>
                    <li>close</li>
                    <li>_exit</li>
                </ul>
                All of the above functions must go through the kernel. <br>
                <br>
                Don't use:
                <ul>
                    <li>stdio (printf, fopen, fclose)</li>
                    <li>malloc, free</li>
                    <li>any function that looks at shared memory</li>
                </ul>
                <br>
                Safe version:
                <pre>
                    <code>
void bing(int sig) {
    write(1, "BING!\n", 6);
    _exit(27);
}
                    </code>
                </pre>
                <br>
                A couple of more signals:<br>
                <ul>
                    <li>SIG_DFL</li>
                    <li>SIG_IGN <= discard signals</li>
                </ul>
                <br>
                <pre>
                    <code>
int pthread_sigmask(int hav,
                    sigset_t const * restrict set,
                    sigset_t * restrict oset);
                    </code>
                </pre>
                1st param: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK<br>
                // while you're doing something important, you won't be bothered by a signal.<br>
                <br>
                Let's take a look at a dangerous situation that can be caused by sending a signal when the CPU is executing sensitive instructions.<br>
                <br>
                gzip foo => foo.gz<br>
                What happens when you press ^C?<br>
                <br>
                <pre>
                    <code>
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", OWRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    unlink("foo");
                    </code>
                </pre>
                If the process gets interrupted, we want either to orginal foo to be restored or the completely zipped foo.gz.  What we don't want is some interleaved output or to lose all of our data in the case of a signal. <br>
                <br>
                One fix:<br>
                <pre>
                    <code>
    signal(SIGINT, SIG_IGN); // but then we can't use ^C
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", O_WRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    unlink("foo");
                    </code>
                </pre>
                Better fix:<br>
                <pre>
                    <code>
    signal(SIGINT, cleanup);
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", O_WRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    unlink("foo"); // but what if we exit after this line? We would lose both foo and foo.gz

    void cleanup(int sig) {
        unlink("foo.gz");
        _exit(97);
    }
                    </code>
                </pre>
                A suggested solution to this problem was to set an integer flag, but that would most likely be optimized out by the compiler. <br>
                <br>
                Better still:<br>
                <pre>
                    <code>
    signal(SIGINT, cleanup);
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", O_WRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    pthread sigmask(SIG_BLOCK);
    unlink("foo");
                    </code>
                </pre>
                <h4>Threads</h4><br>
                <br>
                Threads are like light weight processes.
                <ul>
                    <li>we want a lot of them</li>
                    <li>we want fast context-switching</li>
                    <li>threads are not insulated from each other (shared memory) -> faster communication</li>
                </ul>
                <br>
                Goal = Performance!<br>
                Pros and Cons:
                <pre>
+ performance
- simplicity (can be very complicated and lead to race conditions)
- reliability
                </pre>
                Usually you can get two out of the three ^^.  You generally have to sacrifice simplicity. <br>
                <br>
                <table>
                    <body>
                        <tr>
                            <td><b>Threads</b></td><td></td><td></td><td><b>Processes</b></td>
                        </tr>
                        <tr>
                            <td>pthread_create</td><td></td><td></td><td>fork (or posix_spawn)</td>
                        </tr>
                        <tr>
                            <td>pthread_join</td><td></td><td></td><td>waitpid</td>
                        </tr>
                        <tr>
                            <td>pthread_exit</td><td></td><td></td><td>_exit</td>
                        </tr>
                    </body>
                </table>
                    Note: Threads share memory while processes are isolated.
                    <br><br><br><br><br><br><br><br><br><br>
            </p>
            

</BODY>

</HTML>