<HTML>
<HEAD>
<TITLE>CS111: Lecture 6 Scribe Notes (10/22/14)</TITLE>
<style>
    td {
        font-family: Verdana, Helvetica, Arial, sans-serif;
        font-size: 10pt;
    }
    pre{
        color: $0033CC;
    }

    h2 {
        line-height: 40pt;
    }
    .new {
        color:#CC3300;
    }
    .new2{
        color:#CC0066;
    }
</style>
</HEAD>
<BODY>
<div align=center>
    <table border=0 width=500>
        <tr><td>

            <h1>CS 111</h1>
            <h3>Lecture 6 Scribe Notes</h3>
            <i>by Thomas Lutton & Nicholas Yee</i>

            <h2>What can go wrong? (cont'd)</h2>
            <p>
                <h4>File descriptors:</h4>
                <ul>
                    <li>close(-1) close(39) == 1 errno == EBADF</li>
                    <li>fd = open(...) read(fd)... fd leak</li>
                    <li>fd = open("/dev/usb/dr1"...) read(fd, ...) *unplug* read(fd, ...) // return -1</li>
                </ul>
                <h4>Race Conditons:</h4>
                (cat a & cabt b) > outfile // DIAGRAM <br>
                (cat > a & cat > b) < infile // DIAGRAM <br>
                (cat a & cat b) | (cat > c & cat > d) <br>
                Behavior depends on timing, which is variable => hard to debug <br>

                <h4> Task: rotate a log file </h4>
                    log       <= apache writes to this (today's log), constantly g<br>
                    oldlog    <= yesterday's log<br>
                    <br>
                    at midnight:<br>
                        $ mv log old log<br>
                        $ >log<br>
                    <br>
                    now: <br>
                    write(fd, "good stuff\n", 11);<br>
                    write(fd, "more good stuff\n", 16);<br>
                    <br>
                    change:<br>
                    checklog();<br>
                    write(fd, "good stuff\n", 11);<br>
                    checklog();<br>
                    write(fd, "more good stuff\n", 16);<br>
                    <br>
                    <pre>
                        <code>
int checklog(void) {
    if(stat("log", &st) < 0 || st.st_size == 0) {
        close(fd);
        fd = open("log",...);
    }
}
                        </code>
                    </pre>
                    <br>
                    Now there are two system calls every time instead of one every time that apache writes.  This is very SLOW. <br>
                    <br>
                    This approach: <i>POLLING</i><br>
                    <br>
                    What would happen if the power failed? We would have the same issue. <br>
                    <br>

                <h4>Signals</h4>
                Let's start this section with an analogy.<br>
                signals : processes :: traps : hardware.<br>
                That's right, signals work for processes in the same way that traps work for hardware.<br>
                <br>
                traps - after any machine instruction, the equivalent of INT 0x80 can occur.<br>
                <br>
                signals - the kernel can take control and:<br>
                <ul>
                    <li>terminate processes</li>
                    <li>continue as before</li>
                    <li>cause program to call one of your functions with an asynchronous function call</li>
                </ul>
                Using signals is a good way to avoid wasting CPU resources by polling.<br>
                <br>
                <table>
                    <body>
                        <tr>
                            <td><b>Signal</b></td><td><b>Meaning</b></td><td><b>Additional Info</b></td>
                        </tr>
                        <tr>
                            <td>SIGINT</td><td>interrupt ^C</td><td> <= uncooperative process</td>
                        </tr>
                        <tr>
                            <td>SIGHUP</td><td>hang up</td><td><= unexpected loss of resources</td>
                        </tr>
                        <tr>
                            <td>SIGSEGV</td><td>segmentation violations</td>
                        </tr>
                        <tr>
                            <td>SIGBUS</td><td>bus error</td>
                        </tr>
                        <tr>
                            <td>SIGFPE</td><td>floating point exception</td><td> almost impossible to see nowadays</td>
                        </tr>
                        <tr>
                            <td>SIGPIPE</td><td>writing to pipe with no readers</td>
                        </tr>
                        <tr>
                            <td>SIGKILL</td><td>immediately makes process die</td>
                        </tr>
                        <tr>
                            <td>SIGALRM</td><td>alarm clock</td>
                        </tr>
                        <tr>
                            <td>SIGXCPU</td><td>CPU quota exceeded limit</td>
                        </tr>
                        <tr>
                            <td>SIGXFS2</td><td>file size</td>
                        </tr>
                    </body>
                </table>
                <pre>
                    <code>
int kill(pid_t pid, int sig); // send signal to process
    // can send only to own processes on lnxsrv

pid_t p = fork();
if(p > 0) {
    sleep(30);
    kill(p, SIGINT);
}
wait_pid(p, ...); // weird exit status > 127
                    </code>
                </pre>
                <pre>
                    <code>
typedef void (*sighandler_t)(int);
sighandler_t signal(int, sighandler_t); // int is sig num, returns old handler
                    </code>
                    <br>
example:
                    <code>
int main(void) {
    signal(SIGALRM, bing); // set up handler before action that provokes signal
    alarm(30);
    // really complicated main code
    return 0;
}
void bing(int sig) {
    printf("BING! %d\n", sig);
    exit(27);
}
                    </code>
                </pre>
                But there's a problem! What if the signal arrives when printf is active? This will result in undefined behavior.<br>
                <pre>
    stack:
        printf
        bing
        delicate stuff
        printf
        main
                </pre>
                Solution? Don't call printf or exit! Stick to safe function calls in the handler.<br>
                <br>
                asynchronus_safe functions:
                <ul>
                    <li>write</li>
                    <li>read</li>
                    <li>close</li>
                    <li>_exit</li>
                </ul>
                All of the above functions must go through the kernel. <br>
                <br>
                Don't use:
                <ul>
                    <li>stdio (printf, fopen, fclose)</li>
                    <li>malloc, free</li>
                    <li>any function that looks at shared memory</li>
                </ul>
                <br>
                Safe version:
                <pre>
                    <code>
void bing(int sig) {
    write(1, "BING!\n", 6);
    _exit(27);
}
                    </code>
                </pre>
                <br>
                A couple of more signals:<br>
                <ul>
                    <li>SIG_DFL</li>
                    <li>SIG_IGN <= discard signals</li>
                </ul>
                <br>
                <pre>
                    <code>
int pthread_sigmask(int hav,
                    sigset_t const * restrict set,
                    sigset_t * restrict oset);
                    </code>
                </pre>
                1st param: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK<br>
                // while you're doing something important, you won't be bothered by a signal.<br>
                <br>
                Let's take a look at a dangerous situation that can be caused by sending a signal when the CPU is executing sensitive instructions.<br>
                <br>
                gzip foo => foo.gz<br>
                What happens when you press ^C?<br>
                <br>
                <pre>
                    <code>
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", OWRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    unlink("foo");
                    </code>
                </pre>
                If the process gets interrupted, we want either to orginal foo to be restored or the completely zipped foo.gz.  What we don't want is some interleaved output or to lose all of our data in the case of a signal. <br>
                <br>
                One fix:<br>
                <pre>
                    <code>
    signal(SIGINT, SIG_IGN); // but then we can't use ^C
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", O_WRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    unlink("foo");
                    </code>
                </pre>
                Better fix:<br>
                <pre>
                    <code>
    signal(SIGINT, cleanup);
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", O_WRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    unlink("foo"); // but what if we exit after this line? We would lose both foo and foo.gz

    void cleanup(int sig) {
        unlink("foo.gz");
        _exit(97);
    }
                    </code>
                </pre>
                A suggested solution to this problem was to set an integer flag, but that would most likely be optimized out by the compiler. <br>
                <br>
                Better still:<br>
                <pre>
                    <code>
    signal(SIGINT, cleanup);
    int in = open("foo", O_RDONLY);
    int out = open("foo.gz", O_WRONLY);
    magiczip(in, out);
    close(in);
    close(out);
    pthread sigmask(SIG_BLOCK);
    unlink("foo");
                    </code>
                </pre>






            </p>
            

</BODY>

</HTML>